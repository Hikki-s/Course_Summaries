# Шпаргалка по базовым командам в консоли и Git

## Содержание
- [Навигация по файловой системе](#навигация-по-файловой-системе)
- [Работа с файлами и папками](#работа-с-файлами-и-папками)
    - [Создание](#создание)
    - [Копирование и перемещение](#копирование-и-перемещение)
    - [Чтение](#чтение)
    - [Удаление](#удаление)
- [Полезные возможности](#полезные-возможности)
- [Начало работы с Git](#начало-работы-с-git)
  - [Настраиваем Git](#настраиваем-git)
  - [Проверяем SSH-ключи](#проверяем-ssh-ключи)
  - [Создаём новый SSH-ключ](#создаём-новый-ssh-ключ)
  - [Добавляем SSH-ключ в ssh-agent](#добавляем-ssh-ключ-в-ssh-agent)
  - [Копируем SSH-ключ](#копируем-ssh-ключ)
- [Часто используемые комманды Git](#часто-используемые-комманды-git)
    - [Инициализация репозитория](#инициализация-репозитория)
    - [Синхронизация локального и удалённого репозиториев](#синхронизация-локального-и-удалённого-репозиториев)
    - [Подготовка файла к коммиту](#подготовка-файла-к-коммиту)
    - [Создание и публикация коммита](#создание-и-публикация-коммита)
    - [Откладывание кода](#откладывание-кода)
    - [Просмотр информации о коммитах](#просмотр-информации-о-коммитах)
    - [Просмотр состояния файлов](#просмотр-состояния-файлов)
    - [Добавление изменений в последний коммит](#добавление-изменений-в-последний-коммит)
    - [Откат файлов и коммитов](#откат-файлов-и-коммитов)
    - [Просмотр изменений](#просмотр-изменений)
- [Работа с ветками](#работа-с-ветками)
    - [Клонирование чужого репозитория](#клонирование-чужого-репозитория)
    - [Черрипик (Cherry-pick)](#черрипик-cherry-pick)
    - [Создание веток](#создание-веток)
    - [Навигация по веткам](#навигация-по-веткам)
    - [Сравнение веток](#сравнение-веток)
    - [Удаление веток](#удаление-веток)
    - [Слияние веток](#слияние-веток)
    - [Работа с удалённым репозиторием](#работа-с-удалённым-репозиторием)
    - [Просмотр истории](#просмотр-истории)
    - [Rebase коммитов](#rebase-коммитов)
---

## Навигация по файловой системе
* `pwd` (от англ. print working directory, «показать рабочую папку») — покажи, в какой я папке;
* `ls` (от англ. list directory contents, «отобразить содержимое директории») — покажи файлы и папки в текущей папке;
* `ls -a` — покажи также скрытые файлы и папки, названия которых начинаются с символа .;
* `cd first-project` (от англ. change directory, «сменить директорию») — перейди в папку first-project;
* `cd first-project/html` — перейди в папку html, которая находится в папке first-project;
* `cd ..` — перейди на уровень выше, в родительскую папку;
* `cd ~` — перейди в домашнюю директорию (/Users/Username);
* `cd /` — перейди в корневую директорию.

## Работа с файлами и папками

### Создание
* `touch index.html` (англ. touch, «коснуться») — создай файл index.html в текущей папке;
* `touch index.html style.css script.js` — если нужно создать сразу несколько файлов, можно напечатать их имена в одну строку через пробел;
* `mkdir second-project` (от англ. make directory, «создать директорию») — создай папку с именем second-project в текущей папке.

### Копирование и перемещение
* `cp file.txt ~/my-dir` (от англ. copy, «копировать») — скопируй файл в другое место;
* `mv file.txt ~/my-dir` (от англ. move, «переместить») — перемести файл или папку в другое место.

### Чтение
* `cat file.txt` (от англ. concatenate and print, «объединить и распечатать») — распечатай содержимое текстового файла file.txt.

### Удаление
* `rm about.html` (от англ. remove, «удалить») — удали файл about.html;
* `rmdir images` (от англ. remove directory, «удалить директорию») — удали папку images;
* `rm -r second-project` (от англ. remove, «удалить» + recursive, «рекурсивный») — удали папку second-project и всё, что она содержит.
 
## Полезные возможности
* Команды необязательно печатать и выполнять по очереди. Можно указать их списком — разделить двумя амперсандами (&&).
* У консоли есть собственная память — буфер с несколькими последними командами. По ним можно перемещаться с помощью клавиш со стрелками вверх (↑) и вниз (↓).
* Чтобы не вводить название файла или папки полностью, можно набрать первые символы имени и дважды нажать Tab. Если файл или папка есть в текущей директории, командная строка допишет путь сама.  
     Например, вы находитесь в папке dev. Начните вводить cd first и дважды нажмите Tab. Если папка first-project есть внутри dev, командная строка автоматически подставит её имя. Останется только нажать Enter.

---

## Начало работы с Git

---

### Настраиваем Git

Нужно ввести имя и адрес электронной почты, чтобы ваши действия в Git были подписаны, а ещё для привязки к GitHub.

  #### Добавить имя (введите его внутри кавычек):

  `git config --global user.name "ваше имя"`
  #### Добавить электронную почту (замените email@example.com на вашу почту):

  `git config --global user.email email@example.com`

Опция --global значит, что имя и почта будут использоваться для всех ваших действий в Git. Если вы хотите менять эту информацию для разных проектов, то вводите эти же команды, только без опции --global.

### Проверяем SSH-ключи
  Перед созданием нового SSH-ключа проверим, есть ли на компьютере другие ключи. Обычно они лежат в папке с названием .ssh — поэтому посмотрим, есть ли в ней что-то, с помощью команды в терминале:

  `ls -al ~/.ssh`

  Если у вас уже есть SSH-ключ, то в списке будут файлы с именами вроде id_rsa.pub, id_ecdsa.pub или id_ed25519.pub. 
  
  А если терминал ругается, что директории ~/.ssh не существует, значит, у вас нет SSH-ключей.

### Создаём новый SSH-ключ
  Откройте терминал и скопируйте туда эту команду. Не забудьте подставить в кавычки почту, на которую вы регистрировались на Гитхабе.
  
    
  ```ssh-keygen -t ed25519 -C "your_email@example.com"```
  
  **ed25519** — это алгоритм для генерации ключей. Если ваша система не поддерживает алгоритм ed25519 (и вы увидели ошибку), используйте немного другую команду с алгоритмом rsa:
  
  ```ssh-keygen -t rsa -b 4096 -C "your_email@example.com"```
  
  Терминал спросит, куда сохранить ключ. Если не хотите менять имя файла, которое предлагает терминал, просто нажмите Enter.
  
  ```
    > Generating public/private имя-ключа key pair.
    > Enter a file in which to save the key (/c/Users/ваш-профиль/.ssh/id_имя-ключа):*[Press enter]*
  ```
  
  Теперь нужно добавить пароль, которым будет зашифрован ваш ключ. Это стоит сделать, иначе в дальнейшем могут быть проблемы с настройкой, да и так просто безопаснее.
  
  В результате создаётся новый SSH-ключ, привязанный к вашей электронной почте.

### Добавляем SSH-ключ в ssh-agent
  **ssh-agent** — программа для хранения и управления SSH-ключами. Давайте запустим её и добавим туда наш SSH-ключ. Запускаем командой eval "$(ssh-agent -s)":

  `eval "$(ssh-agent -s)"`

  Если в ответ терминал покажет надпись «Agent pid» и число — значит, всё ок, агент запущен.
  
  Теперь добавим наш ключ командой.
  
  `ssh-add ~/.ssh/id_ed25519`
  
  Если у вашего ключа другое имя, замените название id_ed25519 именем файла с ключом (это правило применяется и дальше в инструкции). Если вы устанавливали пароль на ключ, введите его два раза после ввода команды ssh-add (терминал подскажет, когда это сделать).
  
  Теперь, если всё хорошо, появится надпись Identity added — значит, можно переходить к добавлению ключа на GitHub.
### Копируем SSH-ключ
  Чтобы добавить ключ на GitHub, нужно сначала его скопировать из вашего файла командой clip. Вы не увидите ключ на экране, но он появится в буфере обмена, и его можно будет вставить на Гитхаб.
  
  `clip < ~/.ssh/id_ed25519.pub`

  Команда clip может не сработать на вашем компьютере, тогда есть два способа узнать ключ — простой и сложный.
  
  Сложный способ. Найдите скрытую папку .ssh, откройте файл id_ed25519.pub в текстовом редакторе и скопируйте его содержимое.
  
  Простой способ. Введите команду ниже и ключ появится прямо в терминале — его нужно вручную скопировать в буфер обмена. Ключ начинается с ssh-ed22519 или ssh-rsa (или похожей строки) — поэтому копируйте строку прямо с самого начала.
  
  `~ cat ~/.ssh/id_ed25519.pub`

  Далее добавляем SSH-ключ на GitHub:
  https://github.com/settings/keys

В поле Title нужно добавить название нового ключа. Например, если вы используете Mac, вы можете назвать ключ MacBook Air

---

## Часто используемые комманды Git

---

### Инициализация репозитория
* `git init` (от англ. initialize, «инициализировать») — инициализируй репозиторий.

### Синхронизация локального и удалённого репозиториев
* `git remote add origin https://github.com/Hikki-s/Course_Summaries.git` (от англ. remote, «удалённый» + add, «добавить») — привяжи локальный репозиторий к удалённому с URL https://github.com/Hikki-s/Course_Summaries.git;
* `git remote -v` (от англ. verbose, «подробный») — проверь, что репозитории действительно связались;
* `git push -u origin main` (от англ. push, «толкать») — в первый раз загрузи все коммиты из локального репозитория в удалённый с названием origin.
* #### 💡 Ваша ветка может называться master, а не main. Подправьте команду, если это необходимо.
* `git push` (от англ. push, «толкать») — загрузи коммиты в удалённый репозиторий после того, как он был привязан с помощью флага -u.

### Подготовка файла к коммиту
* `git add todo.txt` (от англ. add, «добавить») — подготовь файл todo.txt к коммиту;
* `git add --all` (от англ. add, «добавить» + all, «всё») — подготовь к коммиту сразу все файлы, в которых были изменения, и все новые файлы;
* `git add .` — подготовь к коммиту текущую папку и все файлы в ней.

### Создание и публикация коммита
* `git commit -m "Комментарий к коммиту."` (от англ. commit, «совершать», фиксировать» + message, «сообщение») — сделай коммит и оставь комментарий, чтобы было проще понять, какие изменения сделаны;
* `git push` (от англ. push, «толкать») — добавь изменения в удалённый репозиторий.

### Откладывание кода
* `git stash` — позволяет на время «сдать в архив» (или отложить) изменения, сделанные в рабочей копии, чтобы вы могли применить их позже.
* ### Запуск git stash с параметром -u (или --include-untracked) позволяет отложить неотслеживаемые файлы:
* `git stash pop` — применяет ранее отложенные изменения.
* `git stash apply` — применяет изменения к рабочей копии, не удаляя их из набора отложенных изменений.
* `git stash list` — команду git stash можно выполнить несколько раз, после чего можно будет просмотреть список созданных наборов.
* ### Рекомендуем добавлять к отложенным изменениям описание в качестве подсказки. Для этого используется команда git stash save "сообщение"
* `git stash pop stash@{2}` — если вам нужно применить определенный набор ранее отложенных изменений, укажите его идентификатор в качестве последнего аргумента.
* `git stash branch` — создание ветки из отложенных изменений.
* `git stash drop stash@{1}` — удалить определенный набор отложенных изменений.
* `git stash clear` — команда удаляет все наборы отложенных изменений.

### Просмотр информации о коммитах
* `git log` (от англ. log, «журнал [записей]») — выведи подробную историю коммитов;
* `git log --oneline` (от англ. log, «журнал [записей]» + oneline, «одной строкой») — покажи краткую информацию о коммитах: сокращённый хеш и сообщение.
 
### Просмотр состояния файлов
* `git status` (от англ. status, «статус», «состояние») — покажи текущее состояние репозитория.

### Добавление изменений в последний коммит
* `git commit --amend --no-edit` (от англ. amend, «исправить») — добавь изменения к последнему коммиту и оставь сообщение прежним;
* `git commit --amend -m "Новое сообщение"` — измени сообщение к последнему коммиту на Новое сообщение.
* #### 💡 Выйти из редактора Vim: нажать Esc, ввести :qa!, нажать Enter.

### «Откат» файлов и коммитов
* `git restore --staged hello.txt` (от англ. restore, «восстановить») — переведи файл hello.txt из состояния staged обратно в untracked или modified;
* `git restore hello.txt` — верни файл hello.txt к последней версии, которая была сохранена через git commit или git add;
* `git reset --hard b576d89` (от англ. reset, «сброс», «обнуление» + hard, «суровый») — удали все незакоммиченные изменения из staging и «рабочей зоны» вплоть до указанного коммита.

### Просмотр изменений
* `git diff` (от англ. difference, «отличие», «разница») — покажи изменения в «рабочей зоне», то есть в modified-файлах;
* `git diff a9928ab 11bada1` — выведи разницу между двумя коммитами;
* `git diff --staged` — покажи изменения, которые добавлены в staged-файлах.

---

## Работа с ветками

---

### Клонирование чужого репозитория
* `git clone git@github.com:Hikki-s/Course_Summaries.git` (от англ. clone, «клон», «копия») — склонируй репозиторий с URL Course_Summaries.git из аккаунта Hikki-s на мой локальный компьютер.

### Черрипик (Cherry-pick)
* `git cherry-pick <hash коммита>` — скопируй конкретный коммит из другой ветки в свою текущую ветку. Это удобно, если ты хочешь применить исправление или нужные изменения из одного места в код другой ветки без полного слияния.
* #### 💡 Не забудь сначала получить последние изменения из удалённого репозитория: git fetch origin.

### Создание веток
* `git branch feature/the-finest-branch` (от англ. branch, «ветка») — создай ветку от текущей с названием feature/the-finest-branch;
* `git checkout -b feature/the-finest-branch` — создай ветку feature/the-finest-branch и сразу переключись на неё.
* `git branch -m` <старое название> <новое название> (от англ. move, «переместить») — переименовывает существующую ветку.

### Навигация по веткам
* `git branch (от англ. branch, «ветка»)` — покажи, какие есть ветки в репозитории и в какой из них я нахожусь (текущая ветка будет отмечена символом *);
* `git branch -a` — покажи все известные ветки, как локальные (в локальном репозитории), так и удалённые (в origin, или на GitHub).
* `git checkout feature/br` — переключись на ветку feature/br.

### Сравнение веток
* `git diff main HEAD` (от англ. difference, «отличие», «разница») — покажи разницу между веткой main и указателем на HEAD;
* `git diff HEAD~2 HEAD` — покажи разницу между тем коммитом, который был два коммита назад, и текущим.

### Удаление веток
* `git branch -d br-name` — удали ветку br-name, но только если она я вляется частью main;
* `git branch -D br-name` — удали ветку br-name, даже если она не объединена с main.

### Слияние веток
* `git merge main` (от англ. merge, «сливать», «поглощать») — объедини ветку main с текущей активной веткой.
* `git merge --no-ff feature/the-finest-branch` — выполни слияние без fast-forward, сохраняя историю веток.

### Работа с удалённым репозиторием
* `git push -u origin my-branch` (от англ. push, «толкнуть», «протолкнуть») — отправь новую ветку my-branch в удалённый репозиторий и свяжи локальную ветку с удалённой, чтобы при дополнительных коммитах можно было писать просто git push без -u;
* `git push my-branch` — отправь дополнительные изменения в ветку my-branch, которая уже существует в удалённом репозитории;
* `git pull` (от англ. pull, «вытянуть») — подтяни изменения текущей ветки из удалённого репозитория.
* `git fetch <remote>` — загружает изменения из удалённого репозитория, не сливая их с локальной веткой.

### Просмотр истории
* `git reflog` (от англ. reference log, «журнал ссылок») — покажи историю перемещений указателя HEAD, что позволяет отслеживать все изменения, даже если коммиты были удалены.

### Rebase коммитов
* `git rebase <ветка>` (от англ. rebase, «перенести основание») — позволяет перенести изменения с одной ветки на другую. Это полезно для того, чтобы упорядочить историю коммитов и избежать лишних слияний (merge).
  #### 💡 Перед выполнением rebase рекомендуется выполнить git pull или git fetch, чтобы получить последние изменения из удалённого репозитория и избежать конфликтов.
  #### Пример:
   Если вы работаете в ветке feature и хотите перенести изменения из ветки main, выполните:
    ```bash
    git checkout feature
    git rebase main
* `git rebase -i <hash коммита>` (интерактивный rebase) — позволяет редактировать коммиты, которые были сделаны после указанного коммита. С помощью этой команды можно изменять порядок коммитов, объединять их (squash), изменять сообщения и даже удалять коммиты.
  #### 💡 После выполнения команды откроется текстовый редактор, в котором можно будет выбрать действия для каждого коммита (pick, squash и т. д.). Не забудьте сохранить изменения перед выходом из редактора.
* `git rebase --continue` — используется для продолжения процесса rebase после разрешения конфликтов. После исправления конфликтов выполните эту команду, чтобы завершить процесс.
* `git rebase --abort` — отменяет текущий процесс rebase и возвращает вас к состоянию, в котором вы находились до его начала, если возникли проблемы или конфликты.
